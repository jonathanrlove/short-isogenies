//This file can be used to produce the vertex and edge information for
//"Isogeny graphs" of maximal orders in a quaternion algebra.
//See "Instructions and graph plotting.nb" for how to use.

function MakeMaxOrder(p)
    //Creates a maximal order in the quaternion algebra ramified at p (odd prime) and infinity

    if not IsPrime(p) or p eq 2 then
        error Error("Input must be odd prime");
    end if;
    if p mod 4 eq 3 then
        A<i,j,k> := QuaternionAlgebra<Rationals() | -1, -p>;
        return QuaternionOrder([1, i, (1+j)/2, (i+k)/2]);
    elif p mod 8 eq 5 then
        A<i,j,k> :=  QuaternionAlgebra<Rationals() | -2, -p>;
        return QuaternionOrder([1, i, (1+j+k)/2, (i+2*j+k)/4]);
    else
        q := 3;
        while not (q mod 4 eq 3 and LegendreSymbol(-p, q) eq 1) do
            q := NextPrime(q);
        end while;
        c := Integers() ! Sqrt(Integers(q) ! -p);
        A<i,j,k> :=  QuaternionAlgebra<Rationals() | -q, -p>;
        return QuaternionOrder([1, (1+i)/2, j, j*(1+i)/2, (c*i+k)/q, (c*i+k)*(1+i)/(2*q)]);
    end if;
end function;

function MinNorm(O : bound:=10000)
    // Find the non-integer element with shortest norm in maximal order O.
    // Search for elements with norm up to bound.

    for curdeg in [1..bound] do
        for c in Enumerate(O, curdeg, curdeg) do
            elt :=  c[1]*Basis(O)[1] + c[2]*Basis(O)[2] + c[3]*Basis(O)[3] + c[4]*Basis(O)[4];
            if elt ne Conjugate(elt) then

                // Compute the fundamental discriminant of the field generated by elt
                disc := Numerator(Discriminant(MinimalPolynomial(elt)));
                funddisc := -1;
                for t in Factorization(disc) do
                    if t[2] mod 2 eq 1 then
                        funddisc *:= t[1];
                    end if;
                end for;
                if funddisc mod 4 ne 1 then
                    funddisc *:= 4;
                end if;

                return [curdeg, funddisc];
            end if;
        end for;
    end for;
    error Error("short element not found. (Increase search bound?)");
    return 0;
end function;

function FindInQueue(elt, lst)
    //Given a list lst of maximal orders, return the index of an entry isomorphic to elt,
    //Or one more than the length of lst if no such entry exists

    for i in [1..#lst] do
        if IsIsomorphic(elt, lst[i]) then
            return i;
        end if;
    end for;
    return #lst + 1;
end function;

function MakeGraph(p, llist)
    //Construct the graph of maximal orders, linked by ideals of norm l for l in llist.
    //When running, it will print the number of maximal orders found so far.
    //Returns:
    //- For each maximal order O, an entry [a, D], where a is a non-integer element of O 
    // with smallest norm, and D is the discriminant of the field generated by a.
    //- A list of pairs [i, j], representing an edge between vertex i and vertex j.
    //- A list of maximal orders (in the same order as the first return value)

    O := MakeMaxOrder(p);
    queue := [O];
    counter := 1;
    edges := [];
    minnorms := [MinNorm(O)];

    while counter le #queue do
        curpt := queue[counter];
        neighbs := <>;
        for l in llist do
            neighbs cat:= <RightOrder(step) : step in MaximalLeftIdeals(curpt, l)>;
        end for;
        for neighb in neighbs do
            place := FindInQueue(neighb, queue);
            if place eq #queue+1 then
                Append(~queue, neighb);
                Append(~minnorms, MinNorm(neighb));
            end if;
            Append(~edges, [counter, place]);
        end for;

        print #queue;
        counter +:= 1;
    end while;
    return minnorms, edges, queue;
end function;

procedure ExportToMathematica(p, llist)
    //Runs MakeGraph and creates a text file that can be loaded into Mathematica.
    minnorms, edges := MakeGraph(p, llist);

    firstline := true;
    for item in minnorms do
        PrintFile("SupsingMinnorms.txt", IntegerToString(item[1]) cat " " cat IntegerToString(item[2]) : Overwrite:=firstline);
        firstline := false;
    end for;
    
    firstline := true;
    for item in edges do
        PrintFile("SupsingEdges.txt", IntegerToString(item[1]) cat " " cat IntegerToString(item[2]) : Overwrite:=firstline);
        firstline := false;
    end for;
end procedure;